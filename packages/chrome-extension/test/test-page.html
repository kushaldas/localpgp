<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LocalPGP Test Page</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
      background: #f5f5f5;
    }
    h1 {
      margin-bottom: 20px;
      color: #333;
    }
    .test-section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-section h2 {
      font-size: 18px;
      margin-bottom: 15px;
      color: #444;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .test-row {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    .test-input, .test-output {
      flex: 1;
    }
    label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      color: #666;
      margin-bottom: 5px;
    }
    textarea {
      width: 100%;
      height: 120px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }
    input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    button {
      padding: 10px 20px;
      background: #4a90d9;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
      margin-top: 10px;
    }
    button:hover {
      background: #3a7bc8;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      font-size: 13px;
    }
    .status.success {
      background: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #c8e6c9;
    }
    .status.error {
      background: #ffebee;
      color: #c62828;
      border: 1px solid #ffcdd2;
    }
    .status.pending {
      background: #fff3e0;
      color: #ef6c00;
      border: 1px solid #ffe0b2;
    }
    .key-info {
      font-family: monospace;
      font-size: 12px;
      background: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    #connection-status {
      padding: 10px 15px;
      border-radius: 4px;
      margin-bottom: 20px;
      font-weight: 500;
    }
    #test-results {
      margin-top: 20px;
    }
    .test-result {
      display: flex;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #eee;
    }
    .test-result:last-child {
      border-bottom: none;
    }
    .test-result .name {
      flex: 1;
      font-weight: 500;
    }
    .test-result .badge {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }
    .test-result .badge.pass {
      background: #e8f5e9;
      color: #2e7d32;
    }
    .test-result .badge.fail {
      background: #ffebee;
      color: #c62828;
    }
    .test-result .badge.pending {
      background: #fff3e0;
      color: #ef6c00;
    }
    #run-all-tests {
      background: #43a047;
    }
    #run-all-tests:hover {
      background: #388e3c;
    }
  </style>
</head>
<body>
  <h1>üîê LocalPGP Test Page</h1>
  
  <div id="connection-status" class="status pending">Checking connection...</div>
  
  <div class="key-info">
    <strong>Test Key:</strong> 5286C32E7C71E14C4C82F9AE0B207108925CB162<br>
    <strong>Default PIN:</strong> 123456 (for Yubikey operations)
  </div>

  <button id="run-all-tests">‚ñ∂ Run All Tests</button>

  <!-- Get Keys Test -->
  <div class="test-section">
    <h2>1. Get Keys</h2>
    <div class="test-row">
      <div class="test-input">
        <label>Pattern (optional)</label>
        <input type="text" id="getkeys-pattern" placeholder="Fingerprint, email, or leave empty for all">
      </div>
      <div class="test-output">
        <label>Result</label>
        <textarea id="getkeys-result" readonly></textarea>
      </div>
    </div>
    <button id="getkeys-btn">Get Keys</button>
    <div id="getkeys-status" class="status" style="display:none;"></div>
  </div>

  <!-- Encrypt Test -->
  <div class="test-section">
    <h2>2. Encrypt</h2>
    <div class="test-row">
      <div class="test-input">
        <label>Plaintext</label>
        <textarea id="encrypt-input">Hello, this is a test message for encryption!</textarea>
        <label style="margin-top:10px;">Recipient Key (fingerprint)</label>
        <input type="text" id="encrypt-key" value="5286C32E7C71E14C4C82F9AE0B207108925CB162">
      </div>
      <div class="test-output">
        <label>Encrypted Output</label>
        <textarea id="encrypt-result" readonly></textarea>
      </div>
    </div>
    <button id="encrypt-btn">Encrypt</button>
    <div id="encrypt-status" class="status" style="display:none;"></div>
  </div>

  <!-- Decrypt Test -->
  <div class="test-section">
    <h2>3. Decrypt</h2>
    <div class="test-row">
      <div class="test-input">
        <label>Encrypted Message (paste PGP message or use output from encrypt)</label>
        <textarea id="decrypt-input" placeholder="-----BEGIN PGP MESSAGE-----&#10;...&#10;-----END PGP MESSAGE-----"></textarea>
      </div>
      <div class="test-output">
        <label>Decrypted Output</label>
        <textarea id="decrypt-result" readonly></textarea>
      </div>
    </div>
    <button id="decrypt-btn">Decrypt</button>
    <button id="copy-encrypted-btn">Copy Encrypted to Decrypt Input</button>
    <div id="decrypt-status" class="status" style="display:none;"></div>
  </div>

  <!-- Sign Test -->
  <div class="test-section">
    <h2>4. Sign (Clearsign)</h2>
    <div class="test-row">
      <div class="test-input">
        <label>Message to Sign</label>
        <textarea id="sign-input">This message will be signed with my private key.</textarea>
        <label style="margin-top:10px;">Signing Key (optional, uses default if empty)</label>
        <input type="text" id="sign-key" value="5286C32E7C71E14C4C82F9AE0B207108925CB162">
      </div>
      <div class="test-output">
        <label>Signed Output</label>
        <textarea id="sign-result" readonly></textarea>
      </div>
    </div>
    <button id="sign-btn">Sign (Clearsign)</button>
    <div id="sign-status" class="status" style="display:none;"></div>
  </div>

  <!-- Verify Test -->
  <div class="test-section">
    <h2>5. Verify Signature</h2>
    <div class="test-row">
      <div class="test-input">
        <label>Signed Message (paste clearsigned message or use output from sign)</label>
        <textarea id="verify-input" placeholder="-----BEGIN PGP SIGNED MESSAGE-----&#10;...&#10;-----END PGP SIGNATURE-----"></textarea>
      </div>
      <div class="test-output">
        <label>Verification Result</label>
        <textarea id="verify-result" readonly></textarea>
      </div>
    </div>
    <button id="verify-btn">Verify</button>
    <button id="copy-signed-btn">Copy Signed to Verify Input</button>
    <div id="verify-status" class="status" style="display:none;"></div>
  </div>

  <!-- Test Results Summary -->
  <div class="test-section">
    <h2>Test Results Summary</h2>
    <div id="test-results">
      <div class="test-result" data-test="connection">
        <span class="name">Connection to gpgme-json</span>
        <span class="badge pending" id="result-connection">Pending</span>
      </div>
      <div class="test-result" data-test="getkeys">
        <span class="name">Get Keys</span>
        <span class="badge pending" id="result-getkeys">Pending</span>
      </div>
      <div class="test-result" data-test="encrypt">
        <span class="name">Encrypt</span>
        <span class="badge pending" id="result-encrypt">Pending</span>
      </div>
      <div class="test-result" data-test="decrypt">
        <span class="name">Decrypt</span>
        <span class="badge pending" id="result-decrypt">Pending</span>
      </div>
      <div class="test-result" data-test="sign">
        <span class="name">Sign</span>
        <span class="badge pending" id="result-sign">Pending</span>
      </div>
      <div class="test-result" data-test="verify">
        <span class="name">Verify</span>
        <span class="badge pending" id="result-verify">Pending</span>
      </div>
      <div class="test-result" data-test="roundtrip">
        <span class="name">Encrypt ‚Üí Decrypt Roundtrip</span>
        <span class="badge pending" id="result-roundtrip">Pending</span>
      </div>
      <div class="test-result" data-test="signverify">
        <span class="name">Sign ‚Üí Verify Roundtrip</span>
        <span class="badge pending" id="result-signverify">Pending</span>
      </div>
    </div>
  </div>

  <script>
    // Test key fingerprint
    const TEST_KEY = '5286C32E7C71E14C4C82F9AE0B207108925CB162';
    
    // Extension ID - will be set by Playwright or detected
    let extensionId = null;

    // Helper to send message to extension
    async function sendToExtension(action, data = {}) {
      return new Promise((resolve, reject) => {
        if (!extensionId) {
          reject(new Error('Extension ID not set'));
          return;
        }
        
        chrome.runtime.sendMessage(extensionId, { action, ...data }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(response);
          }
        });
      });
    }

    // Update status display
    function updateStatus(elementId, success, message) {
      const el = document.getElementById(elementId);
      el.style.display = 'block';
      el.className = `status ${success ? 'success' : 'error'}`;
      el.textContent = message;
    }

    // Update test result badge
    function updateResult(testName, passed, message) {
      const badge = document.getElementById(`result-${testName}`);
      badge.className = `badge ${passed ? 'pass' : 'fail'}`;
      badge.textContent = passed ? 'Pass' : 'Fail';
      badge.title = message || '';
    }

    // Check connection
    async function checkConnection() {
      try {
        const response = await sendToExtension('connect');
        if (response && response.success && response.data?.status === 'connected') {
          document.getElementById('connection-status').className = 'status success';
          document.getElementById('connection-status').textContent = '‚úì Connected to gpgme-json';
          updateResult('connection', true, 'Connected');
          return true;
        } else {
          throw new Error(response?.error || 'Connection failed');
        }
      } catch (error) {
        document.getElementById('connection-status').className = 'status error';
        document.getElementById('connection-status').textContent = `‚úó Connection failed: ${error.message}`;
        updateResult('connection', false, error.message);
        return false;
      }
    }

    // Get Keys
    async function getKeys() {
      const pattern = document.getElementById('getkeys-pattern').value || undefined;
      try {
        const response = await sendToExtension('getKeys', { pattern });
        if (response.success) {
          const keys = response.data;
          document.getElementById('getkeys-result').value = JSON.stringify(keys, null, 2);
          updateStatus('getkeys-status', true, `Found ${keys.length} key(s)`);
          updateResult('getkeys', true, `Found ${keys.length} keys`);
          return keys;
        } else {
          throw new Error(response.error || 'Failed to get keys');
        }
      } catch (error) {
        document.getElementById('getkeys-result').value = error.message;
        updateStatus('getkeys-status', false, error.message);
        updateResult('getkeys', false, error.message);
        throw error;
      }
    }

    // Encrypt
    async function encrypt() {
      const data = document.getElementById('encrypt-input').value;
      const key = document.getElementById('encrypt-key').value;
      try {
        const response = await sendToExtension('encrypt', {
          data,
          publicKeys: [key],
          armor: true
        });
        if (response.success) {
          const encrypted = response.data.data;
          document.getElementById('encrypt-result').value = encrypted;
          updateStatus('encrypt-status', true, 'Encryption successful');
          updateResult('encrypt', true, 'Success');
          return encrypted;
        } else {
          throw new Error(response.error || 'Encryption failed');
        }
      } catch (error) {
        document.getElementById('encrypt-result').value = error.message;
        updateStatus('encrypt-status', false, error.message);
        updateResult('encrypt', false, error.message);
        throw error;
      }
    }

    // Decrypt
    async function decrypt(inputData) {
      const data = inputData || document.getElementById('decrypt-input').value;
      try {
        const response = await sendToExtension('decrypt', { data });
        if (response.success) {
          const decrypted = response.data.data;
          document.getElementById('decrypt-result').value = decrypted;
          updateStatus('decrypt-status', true, 'Decryption successful');
          updateResult('decrypt', true, 'Success');
          return decrypted;
        } else {
          throw new Error(response.error || 'Decryption failed');
        }
      } catch (error) {
        document.getElementById('decrypt-result').value = error.message;
        updateStatus('decrypt-status', false, error.message);
        updateResult('decrypt', false, error.message);
        throw error;
      }
    }

    // Sign
    async function sign() {
      const data = document.getElementById('sign-input').value;
      const key = document.getElementById('sign-key').value || undefined;
      try {
        const response = await sendToExtension('sign', {
          data,
          keys: key ? [key] : undefined,
          mode: 'clearsign',
          armor: true
        });
        if (response.success) {
          const signed = response.data.data;
          document.getElementById('sign-result').value = signed;
          updateStatus('sign-status', true, 'Signing successful');
          updateResult('sign', true, 'Success');
          return signed;
        } else {
          throw new Error(response.error || 'Signing failed');
        }
      } catch (error) {
        document.getElementById('sign-result').value = error.message;
        updateStatus('sign-status', false, error.message);
        updateResult('sign', false, error.message);
        throw error;
      }
    }

    // Verify
    async function verify(inputData) {
      const data = inputData || document.getElementById('verify-input').value;
      try {
        const response = await sendToExtension('verify', { data });
        if (response.success) {
          const result = response.data;
          const resultText = JSON.stringify(result, null, 2);
          document.getElementById('verify-result').value = resultText;
          
          const isValid = result.isValid || (result.signatures && result.signatures.some(s => s.valid));
          if (isValid) {
            updateStatus('verify-status', true, 'Signature is valid');
            updateResult('verify', true, 'Valid signature');
          } else {
            updateStatus('verify-status', false, 'Signature verification failed');
            updateResult('verify', false, 'Invalid signature');
          }
          return result;
        } else {
          throw new Error(response.error || 'Verification failed');
        }
      } catch (error) {
        document.getElementById('verify-result').value = error.message;
        updateStatus('verify-status', false, error.message);
        updateResult('verify', false, error.message);
        throw error;
      }
    }

    // Run all tests
    async function runAllTests() {
      console.log('Running all tests...');
      
      // Reset all badges
      document.querySelectorAll('.badge').forEach(b => {
        b.className = 'badge pending';
        b.textContent = 'Running...';
      });

      // 1. Connection
      const connected = await checkConnection();
      if (!connected) {
        console.error('Connection failed, aborting tests');
        return;
      }

      // 2. Get Keys
      try {
        await getKeys();
      } catch (e) {
        console.error('Get keys failed:', e);
      }

      // 3. Encrypt
      let encrypted;
      try {
        encrypted = await encrypt();
      } catch (e) {
        console.error('Encrypt failed:', e);
      }

      // 4. Decrypt (using encrypted output)
      if (encrypted) {
        try {
          document.getElementById('decrypt-input').value = encrypted;
          const decrypted = await decrypt(encrypted);
          
          // Check roundtrip
          const original = document.getElementById('encrypt-input').value;
          if (decrypted === original) {
            updateResult('roundtrip', true, 'Roundtrip successful');
          } else {
            updateResult('roundtrip', false, 'Decrypted text does not match original');
          }
        } catch (e) {
          console.error('Decrypt failed:', e);
          updateResult('roundtrip', false, e.message);
        }
      } else {
        updateResult('roundtrip', false, 'Encryption failed');
      }

      // 5. Sign
      let signed;
      try {
        signed = await sign();
      } catch (e) {
        console.error('Sign failed:', e);
      }

      // 6. Verify (using signed output)
      if (signed) {
        try {
          document.getElementById('verify-input').value = signed;
          const verifyResult = await verify(signed);
          
          // Check sign-verify roundtrip
          const isValid = verifyResult.isValid || (verifyResult.signatures && verifyResult.signatures.some(s => s.valid));
          if (isValid) {
            updateResult('signverify', true, 'Sign-verify roundtrip successful');
          } else {
            updateResult('signverify', false, 'Signature not valid');
          }
        } catch (e) {
          console.error('Verify failed:', e);
          updateResult('signverify', false, e.message);
        }
      } else {
        updateResult('signverify', false, 'Signing failed');
      }

      console.log('All tests completed');
    }

    // Event listeners
    document.getElementById('getkeys-btn').addEventListener('click', getKeys);
    document.getElementById('encrypt-btn').addEventListener('click', encrypt);
    document.getElementById('decrypt-btn').addEventListener('click', decrypt);
    document.getElementById('sign-btn').addEventListener('click', sign);
    document.getElementById('verify-btn').addEventListener('click', verify);
    document.getElementById('run-all-tests').addEventListener('click', runAllTests);

    document.getElementById('copy-encrypted-btn').addEventListener('click', () => {
      document.getElementById('decrypt-input').value = document.getElementById('encrypt-result').value;
    });

    document.getElementById('copy-signed-btn').addEventListener('click', () => {
      document.getElementById('verify-input').value = document.getElementById('sign-result').value;
    });

    // Set extension ID from URL parameter or window variable (set by Playwright)
    const urlParams = new URLSearchParams(window.location.search);
    extensionId = urlParams.get('extensionId') || window.EXTENSION_ID;
    
    if (extensionId) {
      console.log('Extension ID:', extensionId);
      checkConnection();
    } else {
      document.getElementById('connection-status').className = 'status error';
      document.getElementById('connection-status').textContent = 
        'Extension ID not set. Pass ?extensionId=XXX or set window.EXTENSION_ID';
    }

    // Expose functions for Playwright
    window.testFunctions = {
      checkConnection,
      getKeys,
      encrypt,
      decrypt,
      sign,
      verify,
      runAllTests,
      setExtensionId: (id) => { extensionId = id; }
    };
  </script>
</body>
</html>
